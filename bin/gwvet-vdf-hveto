#!/usr/bin/env python

"""Grab a veto-definer and remove segments from science
"""

from __future__ import print_function

import os
import glob
import sys

from math import (ceil, floor)
from urlparse import urlparse
from urllib2 import urlopen

import numpy
from argparse import ArgumentParser
from getpass import getuser
from subprocess import Popen

from glue.lal import CacheEntry

from gwpy.time import to_gps
from gwpy.segments import (Segment, DataQualityFlag, DataQualityDict)

from gwsumm.config import (GWSummConfigParser as ConfigParser, NoSectionError)
from gwsumm.state import SummaryState
from gwsumm.utils import (re_cchar, mkdir, get_default_ifo)

from gwvet import __version__

__author__ = 'Laura Nuttall <laura.nuttall@ligo.org>'
__credits__ = 'Laura ripped off Duncan'

try:
    IFO = get_default_ifo()
except ValueError:
    IFO = None
#DEFAULT_METRICS = ['Deadtime', 'Efficiency', 'Efficiency/Deadtime', 
#                   'Efficiency | SNR>=8', 'Efficiency/Deadtime | SNR>=8',
#                   'Efficiency | SNR>=10', 'Efficiency/Deadtime | SNR>=10',
#                   'Efficiency | SNR>=20', 'Efficiency/Deadtime | SNR>=20',
#                   'Use percentage', 'Loudest event by SNR']

DEFAULT_METRICS = ['Deadtime', 'Efficiency', 'Efficiency/Deadtime',
                   'Use percentage', 'Loudest event by SNR']

def add_config_section(config, section, **params):
    config.add_section(section)
    for key, val in params.iteritems():
        config.set(section, key, val)

def configure_veto_tab(section, parent, state, flags, segmentfile, metrics,
                       **params):
    tab = 'tab-%s' % section
    config.add_section(tab)
    params.setdefault('type', 'veto-flag')
    params.setdefault('name', section)
    if parent is not None:
        params.setdefault('parent', parent)
    params.setdefault('flags', ','.join(flags))
    params.setdefault('union', '|'.join(flags))
    params.setdefault('intersection', '&'.join(flags))
    params.setdefault('states', state.key)
    params.setdefault('segmentfile', segmentfile)
    params.setdefault('veto-name', params['name'])
    params.setdefault('metrics', ','.join(metrics))
    # set others
    if 'event-channel' in params:
        params.setdefault('before', '%(event-channel)s')
        params.setdefault('after', '%(event-channel)s#%(union)s')
        params.setdefault('vetoed', '%(event-channel)s@%(union)s')
    for key, val in params.iteritems():
        config.set(tab, key, val)
    return tab

# -----------------------------------------------------------------------------
#
# set up command line and parse
#
# -----------------------------------------------------------------------------

parser = ArgumentParser(description=__doc__)
parser.add_argument('-v', '--verbose', action='store_true',
                    help='print verbose output')
parser.add_argument('-V', '--version', action='version', version=__version__)
parser._positionals.title = 'Positional arguments'
parser._optionals.title = 'Optional arguments'

# required argument
parser.add_argument('veto-definer-file', help='path to veto definer file')
parser.add_argument('gps-start-time', type=to_gps,
                    help='GPS start time/date of analysis')
parser.add_argument('gps-end-time', type=to_gps,
                    help='GPS end time/date of analysis')
parser.add_argument('hveto-location', help='path to hveto directory')

analargs = parser.add_argument_group('Analysis options')
analargs.add_argument('-f', '--config-file', type=os.path.abspath,
                      default=[], action='append',
                      help='path to INI file defining this analysis')
analargs.add_argument('-i', '--ifo', default=IFO,
                      help='prefix of IFO to study, default: %(default)s')
analargs.add_argument('-o', '--output-directory', default=os.curdir,
                      type=os.path.abspath,
                      help='output directory path, default: %(default)s, '
                           'this path should be web-viewable')
analargs.add_argument('-c', '--categories', default='1,2,3,4',
                      help='list of categories to analyse, '
                           'default: %(default)s')
analargs.add_argument('-m', '--metric', action='append',
                      help='name of metric to use in analysis, '
                           'can be given multiple times, default: %s'
                           % DEFAULT_METRICS)
analargs.add_argument('-g', '--global-config', action='append', default=[],
                      help='path to gwsumm configuration file passed to all '
                           'gw_summary jobs')

trigargs = parser.add_argument_group('Trigger options')
trigargs.add_argument('-x', '--event-channel',
                      default=IFO and '%s:GDS-CALIB_STRAIN' % IFO or None,
                      help='name of event trigger channel, '
                           'default: %(default)s')
trigargs.add_argument('-G', '--event-generator', default='Omicron',
                      help='name of event trigger generator, '
                           'default: %(default)s')
trigargs.add_argument('-X', '--event-file', help='path to event cache file')

segargs = parser.add_argument_group('Segment options')
segargs.add_argument(
    '-a', '--analysis-segments', action='append',
    default=IFO and ['%s:DMT-ANALYSIS_READY:1' % IFO] or None,
    help='flag indicating analysis time, or path of segment file containing '
         'segments for a single flag, default: %(default)s, can be given '
         'multiple times to use the intersection of many flags, or the union '
         'of many files')
segargs.add_argument('-n', '--analysis-name', default='Analysis',
                     help='Human-readable name for summary state, '
                          'e.g. \'Science\', default: %(default)s')
segargs.add_argument('-t', '--segment-url', dest='segdb',
                     default='https://segments.ligo.org',
                     help='url of segment database, default: %(default)s')
segargs.add_argument('-S', '--on-segdb-error', default='raise',
                     choices=['raise', 'ignore', 'warn'],
                     help='how to handle (dq)segdb errors, '
                          'default: %(default)s')

args = parser.parse_args()

# parse command line options
ifo = args.ifo
if not args.ifo:
    parser.error('--ifo must be given if not obvious from the host')
start = getattr(args, 'gps-start-time')
end = getattr(args, 'gps-end-time')
span = Segment(start, end)
duration = int(ceil(end) - floor(start))
categories = args.categories.split(',')
for i, c in enumerate(categories):
    try:
        categories[i] = int(c)
    except (TypeError, ValueError):
        pass
vetofile = getattr(args, 'veto-definer-file')
if not urlparse(vetofile).netloc:
    vetofile = os.path.abspath(vetofile)
hveto_loc = getattr(args, 'hveto-location')

if not args.metric:
    args.metric = DEFAULT_METRICS

# -----------------------------------------------------------------------------
#
# set things up
#
# -----------------------------------------------------------------------------

tag = '%d-%d' % (start.seconds, end.seconds)
outdir = os.path.abspath(os.path.join(args.output_directory, tag))
mkdir(outdir)
os.chdir(outdir)
mkdir('etc', 'condor')

# -----------------------------------------------------------------------------
#
# veto-definer flags in science
#
# -----------------------------------------------------------------------------

ALLSEGMENTS = DataQualityDict()

# Grab science
aflags = args.analysis_segments
asegments = DataQualityFlag('%s:VET-ANALYSIS_SEGMENTS:0' % ifo)
for i, flag in enumerate(aflags):
    # use union of segments from a file
    if os.path.isfile(flag):
        asegments += DataQualityFlag.read(flag)
    # or intersection of segments from multiple flags
    else:
        new = DataQualityFlag.query(flag, start, end, url=args.segdb)
        if i:
            asegments.known &= new.known
            asegments.active &= new.active
        else:
            asegments.known = new.known
            asegments.active = new.active
ALLSEGMENTS[asegments.name] = asegments

if os.path.isfile(aflags[0]):
    asegments.filename = aflags

# Grab vdf
if urlparse(vetofile).netloc:
    tmp = urlopen(vetofile)
    vetofile = os.path.abspath(os.path.basename(vetofile))
    with open(vetofile, 'w') as f:
        f.write(tmp.read())
    print('Downloaded veto definer file')
vdf = DataQualityDict.from_veto_definer_file(
    vetofile, format='ligolw', start=start, end=end, ifo=ifo)
print('Read %d flags from veto definer' % len(vdf.keys()))

# populate veto definer file from database
vdf.populate(source=args.segdb, on_error=args.on_segdb_error)
ALLSEGMENTS += vdf

# organise flags into categories
flags = dict((c, DataQualityDict()) for c in categories)
for name, flag in vdf.iteritems():
    try:
        flags[flag.category][name] = flag
    except KeyError:
        pass

# find the states and segments for each category
states = dict()
for i, category in enumerate(categories):
    title = isinstance(category, int) and 'Cat %d' % category or category
    tag = re_cchar.sub('_', str(title).upper())
    if i:
        states[category] = SummaryState('After %s' % oldtitle, key=tag,
                                        known=after.known,
                                        active=after.active,
                                        definition=after.name)
    else:
        states[category] = SummaryState(args.analysis_name,
                                        key=args.analysis_name,
                                        definition=asegments.name)
    try:
        segs = flags[category].union()
    except TypeError:  # no flags
        segs = DataQualityFlag()
    segs.name = '%s:VET-ANALYSIS_%s:0' % (ifo, tag)
    ALLSEGMENTS[segs.name] = segs
    if i:
        after = after - segs
    else:
        after = asegments - segs
    after.name = '%s:VET-ANALYSIS_AFTER_%s:0' % (ifo, tag)
    ALLSEGMENTS[after.name] = after
    oldtitle = title

# write all segments to disk
segfile = os.path.abspath('%s-VET_SEGMENTS-%d-%d.xml.gz'
                          % (ifo, start.seconds, duration))
ALLSEGMENTS.write(segfile)

# -----------------------------------------------------------------------------
#
# hveto flags
#
# -----------------------------------------------------------------------------

# Grab veto segments from hveto
hveto_files = glob.glob(os.path.join(hveto_loc,'*VETO_SEGS_ROUND*'))
hveto_flags = DataQualityDict()

# Sort hveto files
nums = []
for i, hflags in enumerate(hveto_files):
    e = CacheEntry.from_T050017(hflags)
    nums.append(int(e.description.split('_')[-1]))
nums, hveto_files = zip(*sorted(zip(nums, hveto_files)))

# gra round channel names 
chan_names=[]
with open(os.path.join(hveto_loc,'summary_stats.txt'), 'r') as filestream:
    for line in filestream:
        currentline = line.split(' ')
        chan_names.append(currentline[1])

# populate hveto_flags
for i, hflags in enumerate(chan_names):
    # parse name
    htag = '%s:ROUND-%s_%s' % (ifo, i+1, hflags.replace('-', '_'))
    # read segments and replace known
    hflag = DataQualityFlag.read(hveto_files[i])
    hflag.name = '%s:1' % (htag)
    e = CacheEntry.from_T050017(hveto_files[i])
    hflag.known = [e.segment]
    hveto_flags[hflag.name] = hflag

# populate hveto_flags
#for i, hflags in enumerate(hveto_files):
#    # parse file name for info
#    e = CacheEntry.from_T050017(hflags)
#    #ifo = e.observatory
#    htag = e.description.replace('_', '-', 1)
#    # read segments and replace known
#    hflag = DataQualityFlag.read(hflags)
#    hflag.name = '%s:%s:1' % (ifo, htag)
#    hflag.known = [e.segment]
#    hveto_flags[hflag.name] = hflag

# write segments to new XML file
hveto_outfile = os.path.abspath('%s-HVETO_FLAG_SEGMENTS-%d-%d.xml'
                          % (ifo, start.seconds, duration))
hveto_flags.write(hveto_outfile)

# -----------------------------------------------------------------------------
#
# job preparation
#
# -----------------------------------------------------------------------------

os.chdir('etc')

configs = []
for category in categories:
    title = isinstance(category, int) and 'Category %d' % category or category
    tab = 'tab-%s' % title

    config = ConfigParser()

    # add segment-database configuration
    add_config_section(config, 'segment-database', url=args.segdb)

    # add plot configurations
    pconfig = ConfigParser()
    pconfig.read(args.config_file)
    for section in pconfig.sections():
        if section.startswith('plot-'):
            config._sections[section] = pconfig._sections[section].copy()

    try:
        plots = pconfig.items('plots-%s' % category, raw=True)
    except NoSectionError:
        try:
            plots = pconfig.items('plots', raw=True)
        except NoSectionError:
            plots = []

    # add state
    state = states[category]
    sname = 'state-%s' % state.key
    add_config_section(config, sname, key=state.key, name=state.name,
                       definition=state.definition, filename=segfile)

    # add plugin
    add_config_section(config, 'plugins', **{'gwvet.tabs': ''})

    # define metrics
    #if category == 1:
    #    metrics = ['Deadtime']
    #else:
    #    metrics = args.metric
    metrics = args.metric

    # define summary tab
    #if category == 1:
    #    tab = configure_veto_tab(
    #        title, title, state, hveto_flags.keys(), hveto_outfile,
    #        metrics, name='Summary', **{'veto-name': title})
    #else:
    tab = configure_veto_tab(
        title, title, state, hveto_flags.keys(), hveto_outfile,
        metrics, name='Summary', **{
            'veto-name': title,
            'event-channel':  args.event_channel,
            'event-generator': args.event_generator,
        })
    if len(categories) == 1:
        config.set(tab, 'index',
                   '%(gps-start-time)s-%(gps-end-time)s/index.html')
    for key, value in plots:
        if re.match('%\(hveto_flags\)s (?:plot-)?segments', value):
            config.set(tab, key, '%%(union)s,%s' % value)
            if '%s-labels' % key not in plots:
                config.set(tab, '%s-labels' % key, 'Union,%(hveto_flags)s')
        else:
            config.set(tab, key, value)

    # now a tab for each flag
    for flag in hveto_flags:
        #if category == 1:
        #    tab = configure_veto_tab(
        #        ('%s-category%s' % (flag,category)), title, state, [flag], 
        #            hveto_outfile, metrics)
        #else:
        tab = configure_veto_tab(
            ('%s-category%s' % (flag,category)), title, state, [flag], 
                hveto_outfile, metrics, **{
                'event-channel': args.event_channel,
                'event-generator': args.event_generator})
        if args.event_file:
            config.set(tab, 'event-file', args.event_file)
        for key, value in plots:
            config.set(tab, key, value)

    if len(categories) > 1 and category != categories[-1]:
        with open('%s.ini' % re_cchar.sub('-', title.lower()), 'w') as f:
            config.write(f)
            configs.append(os.path.abspath(f.name))

# configure summary job
if len(categories) > 1:
    state = states[categories[0]]
    add_config_section(config, 'state-%s' % state.key, key=state.key,
                       name=state.name, definition=state.definition,
                       filename=hveto_outfile)
    try:
        plots = pconfig.items('plots', raw=True)
    except NoSectionError:
        plots = []
    hveto_flags = [f for f in hveto_flags.keys()]
    tab = configure_veto_tab(
        'Impact of all hveto', None, state, hveto_flags,
        hveto_outfile, args.metric, shortname='Summary',
        index='%(gps-start-time)s-%(gps-end-time)s/index.html',
        **{'event-channel': args.event_channel,
           'event-generator': args.event_generator,
           'veto-name': 'All vetoes'})
    if args.event_file:
        config.set(tab, 'event-file', args.event_file)
    for key, value in plots:
        config.set(tab, key, value)
    with open('%s.ini' % re_cchar.sub('-', title.lower()), 'w') as f:
        config.write(f)
        configs.append(os.path.abspath(f.name))

os.chdir(os.pardir)

if args.verbose:
    print("Generated configuration files for each category")

# -----------------------------------------------------------------------------
#
# condor preparation
#
# -----------------------------------------------------------------------------

os.chdir(os.pardir)

# get condor variables
if getuser() == 'detchar':
    accgroup = 'ligo.prod.o1.detchar.dqproduct.gwpy'
else:
    accgroup = 'ligo.dev.o1.detchar.dqproduct.gwpy'

cmd = ['gw_summary_pipe',
       '--gps-start-time', str(start.seconds),
       '--gps-end-time', str(end.seconds),
       '--ifo', ifo,
       '--file-tag', 'gwpy-vet',
       '--condor-command', 'accounting_group=%s' % accgroup,
       '--condor-command', 'accounting_group_user=%s' % getuser(),
       '--on-segdb-error', args.on_segdb_error,
       '--output-dir', args.output_directory,
       ]
for cf in args.global_config:
    cmd.extend(('--global-config', cf))
for cf in configs:
    cmd.extend(('--config-file', cf))
if args.verbose:
    cmd.append('--verbose')

if args.verbose:
    print('Generating summary DAG via:\n')
    print(' '.join(cmd))
    print('')

proc = Popen(cmd)
proc.communicate()
sys.exit(proc.returncode)
